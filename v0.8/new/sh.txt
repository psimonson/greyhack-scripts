//////////////////////////////////////////////////////////
// Name: Simple Shell Reimagined (v3)
// Desc: A full fletched Grey Hack shell for hacking
//       in-game.
// Auth: Philip R. Simonson (aka 5n4k3)
// Date: 08/01/2023
//////////////////////////////////////////////////////////

// Global variables for shell.
globals.name = "sh"
globals.date = "08/01/2023"
globals.coder = "5n4k3"
globals.version = 1.3
globals.running = true
globals.crypto = null
globals.objects = []

// Global variables for database.
globals.db = {}
globals.db.name = "payload"
globals.db.folder = null
globals.db.exploitFilesCount = 0
globals.db.passwordFilesCount = 0
globals.db.names = ["exploits", "passwords"]

// Local variables
crypto = null
vfile = []
dirtyObjects = []

// Local variables for active user and active object.
local = {}
local.user = active_user
local.object = get_shell
local.computer = get_shell.host_computer
local.folder = get_shell.host_computer.File(current_path)
local.router = get_router
local.publicip = get_router.public_ip
local.localip = local.computer.local_ip

// Remote variables for active user and active object.
remote = {}
remote.user = active_user
remote.object = get_shell
remote.computer = get_shell.host_computer
remote.folder = get_shell.host_computer.File(current_path)
remote.router = get_router
remote.publicip = get_router.public_ip
remote.localip = remote.computer.local_ip

current = {}
current.user = remote.user
current.object = remote.object
current.computer = function
    if typeof(current.object) == "shell" then return current.object.host_computer
    if typeof(current.object) == "computer" then return current.object
    return null
end function
current.folder = current.computer.File(current_path)
current.router = remote.router
current.publicip = function
    return current.router.public_ip
end function
current.localip = current.computer.local_ip

// Set the crypto library if it is the local machine.
if remote.publicip == local.publicip and remote.localip == local.localip then
    // Get crypto from local system.
    crypto = include_lib("/lib/crypto.so")
    if not crypto then crypto = include_lib(parent_path(program_path) + "/crypto.so")
    if not crypto then
        print(globals.name + ": Cannot find 'crypto.so' library on system.")
        return false
    end if
end if

// Set the terminal to yours.
interface = get_custom_object
if interface.indexes.len != 2 then
    local = interface.local
    vfile = interface.vfile
    crypto = interface.crypto
    dirtyObjects = interface.dirty
end if

// Global library helper functions.
libs = {}

libs["toFile"] = function(anyObject = null)
    if typeof(anyObject) == "shell" then return anyObject.host_computer.File("/")
    if typeof(anyObject) == "computer" then return anyObject.File("/")
    if typeof(anyObject) == "file" then
        while anyObject.path != "/"
            anyObject = anyObject.parent
        end while
        return anyObject
    end if
    return null
end function

libs["navTo"] = function(anyObject, path = "/")
    if typeof(anyObject) != "file" and typeof(anyObject) != "computer" and typeof(anyObject) != "shell" then
        return null
    end if
    if typeof(path) != "string" then return null
    if path.len == 0 then return null
    
    object = libs.toFile(anyObject)
    if not object then return null

    // Trim trailing '/' character(s) from path.
    while (path.len > 1) and (path[-1] == "/")
        path = path[:-1]
    end while

    // Trim starting '/' character(s) from path.
    while (path.len > 1) and (path[0] == "/")
        path = path[1:]
    end while

    if path == "/" then return object
    path = path.split("/")
    for i in path.indexes
        found = false
        if i == (path.len - 1) then
            for file in object.get_folders + object.get_files
                if file.name != path[i] then continue
                return file
            end for
            return null
        end if

        for file in object.get_folders
            if file.name != path[i] then continue
            found = true
            object = file
            break
        end for
        if not found then return null
    end for

    return object
end function

libs["findAll"] = function(fileObject)
    if typeof(fileObject) != "file" then return null
    
    newList = []
    fileList = fileObject.get_folders + fileObject.get_files
    while fileList.len > 0
        file = fileList.pull
        if file.is_folder then fileList = fileList + file.get_folders + file.get_files
        newList.push(file)
    end while
    return newList
end function

libs["findAllWithRead"] = function(fileList)
    if typeof(fileList) != "list" then return null

    newList = []
    for file in fileList
        // Check for permissions
        if file.has_permission("r") then
            if file.is_folder then
                newList.push({ "type": "folder", "file": file })
            else if file.is_binary then
                newList.push({ "type": "binary", "file": file })
            else
                newList.push({ "type": "text", "file": file })
            end if
        end if
    end for
    return newList
end function

libs["findAllWithWrite"] = function(fileList)
    if typeof(fileList) != "list" then return null

    newList = []
    for file in fileList
        // Check for permissions
        if file.has_permission("w") then
            if file.is_folder then
                newList.push({ "type": "folder", "file": file })
            else if file.is_binary then
                newList.push({ "type": "binary", "file": file })
            else
                newList.push({ "type": "text", "file": file })
            end if
        end if
    end for
    return newList
end function

libs["findAllWithExec"] = function(fileList)
    if typeof(fileList) != "list" then return null

    newList = []
    for file in fileList
        // Check for permissions
        if file.has_permission("x") then
            if file.is_folder then
                newList.push({ "type": "folder", "file": file })
            else if file.is_binary then
                newList.push({ "type": "binary", "file": file })
            else
                newList.push({ "type": "text", "file": file })
            end if
        end if
    end for
    return newList
end function

libs["checkIP"] = function(anyObject, targetIP, targetPort, currentRouter)
    if typeof(anyObject) != "shell" and typeof(anyObject) != "computer" and typeof(anyObject) != "file" then return null
    if not is_valid_ip(targetIP) then return null
    if typeof(targetPort) != "number" then return null
    if typeof(currentRouter) != "router" then return null
    if typeof(anyObject) == "shell" then return { "localip": anyObject.host_computer.local_ip, "publicip": anyObject.host_computer.public_ip, "router": get_router(anyObject.host_computer.public_ip) }
    if typeof(anyObject) == "computer" then return { "localip": anyObject.local_ip, "publicip": anyObject.public_ip, "router": get_router(anyObject.public_ip) }
    if is_lan_ip(targetIP) then return { "localip": targetIP, "publicip": currentRouter.public_ip, "router": currentRouter }
    targetRouter = get_router(targetIP)
    if not targetRouter then return null
    targetPortObject = targetRouter.ping_port(targetPort)
    if targetPortObject then return { "localip": targetPortObject.get_lan_ip, "publicip": targetIP, "router": targetRouter }
    return { "localip": targetRouter.local_ip, "publicip": targetIP, "router": targetRouter }
end function

libs["checkUser"] = function(anyObject)
    file = libs.navTo(anyObject, "/root")
    if file != null then
        if file.has_permission("r") and file.has_permission("w") and file.has_permission("x") then
            return "root"
        end if
    end if
    homeFolder = libs.navTo(anyObject, "/home")
    if homeFolder != null then
        for user in homeFolder.get_folders
            if user.has_permission("r") and user.has_permission("w") and user.has_permission("x") then
                return user.name
            end if
        end for
    end if
    return "guest"
end function

libs["encrypt"] = function(string = "")
    if typeof(string) != "string" then return null
    // TODO: Add your own encryption.
    return string
end function

libs["decrypt"] = function(string = "")
    if typeof(string) != "string" then return null
    // TODO: Add your own decryption.
    return string
end function

libs["dbCheck"] = function
    payload = local.computer.File(local.folder.path + "/" + globals.db.name)
    if not payload then return false
    globals.db.folder = payload

    for name in globals.db.names
        folder = local.computer.File(local.folder.path + "/" + globals.db.name + "/" + name)
        if not folder then return false
        globals.db[name] = folder
    end for

    return true
end function

libs["dbCreate"] = function
    payload = local.computer.File(local.folder.path + "/" + globals.db.name)
    if not payload then
        print("<color=yellow>Creating database folder '" + globals.db.name + "'...</color>")
        local.computer.touch(local.folder.path, globals.db.name)
        payload = local.computer.File(local.folder.path + "/" + globals.db.name)
        if not payload then
            print("<color=red>Folder '" + globals.db.name + "' already created.</color>")
            return false
        else
            print("<color=yellow>Folder '" + globals.db.name + "' created.</color>")
        end if
    end if
    globals.db.folder = payload

    for dbname in globals.db.names
        file = local.computer.File(local.folder.path + "/" + globals.db.name + "/" + dbname)
        if not file then
            print("<color=yellow>Creating database folder '" + dbname + "'...</color>")
            local.computer.touch(local.folder.path + "/" + globals.db.name, dbname)
            file = local.computer.File(local.folder.path + "/" + globals.db.name + "/" + dbname)
            if not file then
                print("<color=red>Folder '" + dbname + "' not created.</color>")
                globals.db[dbname] = null
                return false
            else
                print("<color=yellow>Folder '" + dbname + "' created.</color>")
                globals.db[dbname] = file
            end if
        end if
    end for
    
    return true
end function

libs["dbParseToLines"] = function(result = "")
    if typeof(result) != "string" or result == "" then return null
    lines = result.split(";")[:-1]
    converted = []
    for line in lines
        converted.push(line)
    end for
    return converted
end function

libs["dbStringifyExploits"] = function(result = {})
    if typeof(result) != "map" then return ""
    s = ""
    for memory in result.memorys
        for value in memory.value
            s = s + result.name + ":" + result.version + ":" + memory.key + ":" + value + ";"
        end for
    end for
    return s
end function

libs["dbStringifyLines"] = function(result = [])
    if typeof(result) != "list" then return ""
    s = ""
    for line in result
        s = s + line + ";"
    end for
    return s
end function

libs["dbDelete"] = function(dbName = "")
    if dbName == "" then
        if globals.db.folder == null then return false
        globals.db.folder.delete
        globals.db.folder = null
        for dbname in globals.db.names
            globals.db[dbname] = null
        end for
    else
        if not globals.db.hasIndex(dbName) then return false
        if typeof(globals.db[dbName]) != "file" then return false
        globals.db[dbName].delete
        globals.db[dbName] = null
    end if
    return true
end function

libs["dbParseExploits"] = function(result = "", filename = "")
    if typeof(result) != "string" then return null
    if typeof(filename) != "string" then return null
    if result.indexOf(";") == null then return null
    if result.indexOf(":") == null then return null

    exploits = result.split(";")[:-1]
    ret = {}
    ret.memorys = {}

    for exploit in exploits
        v = exploit.split(":")
        ret.name = v[0]
        ret.version = v[1]
        ret.memorys[v[2]] = []
    end for

    for exploit in exploits
        v = exploit.split(":")
        ret.memorys[v[2]].push(v[3])
    end for

    return ret
end function

libs["dbWriteExploits"] = function(result = null)
    if typeof(result) != "map" then return null

    // Get current file for writing.
    name = "exploit" + str(globals.db.exploitFilesCount) + ".db"
    file = local.computer.File(globals.db.exploits.path + "/" + name)
    if not file then
        local.computer.touch(globals.db.exploits.path, name)
        file = local.computer.File(globals.db.exploits.path + "/" + name)
        if not file then false
    end if

    // Get content and check if in database.
    content = libs.decrypt(file.get_content)
	if typeof(content) != "string" then return false
    stringify = libs.dbStringifyExploits(result)
	if typeof(stringify) != "string" then return false

    if content.len + stringify.len <= 160000 then
        // Process lines
        lines = libs.dbParseToLines(content)
        for line in lines
            v = line.split(":")
            if v[0] == result.name and v[1] == result.version then
                return false
            end if
        end for

        // Write content to database.
        content = content + stringify
        content = libs.encrypt(content)
        result = file.set_content(content)
        if typeof(result) == "string" then return false
    else
        // Get current file for writing.
        globals.db.exploitFilesCount = globals.db.exploitFilesCount + 1
        name = "exploit" + str(globals.db.exploitFilesCount) + ".db"
        file = local.computer.File(globals.db.exploits.path + "/" + name)
        if not file then
            local.computer.touch(globals.db.exploits.path, name)
            file = local.computer.File(globals.db.exploits.path + "/" + name)
            if not file then false
        end if

        // Write content to database.
        content = content + stringify
        content = libs.encrypt(content)
        result = file.set_content(content)
        if typeof(result) == "string" then return false
    end if

    return true
end function

libs["dbQueryExploits"] = function(libname = "", libver = "", doprint = false)
    if globals.db.folder == null or not globals.db.hasIndex("exploits") then return null

    if libname == "" then
        retrieved = []
        for file in globals.db.exploits.get_files
            data = libs.decrypt(file.get_content)
            lines = libs.dbParseToLines(data)
            for line in lines
                v = line.split(":")
                if retrieved.indexOf(v[0]) == null then
                    retrieved.push(v[0])
                end if
            end for
        end for

        for name in retrieved
            print(name)
        end for
    else
        if libver == "" then
            retrieved = []
            for file in globals.db.exploits.get_files
                found = false
                data = libs.decrypt(file.get_content)
                lines = libs.dbParseToLines(data)
                for line in lines
                    v = line.split(":")
                    s = v[0] + ":" + v[1]
                    if v[0] == libname and retrieved.indexOf(s) == null then
                        retrieved.push(s)
                        found = true
                    end if
                end for
                if found then break
            end for

            for line in retrieved
                v = line.split(":")
                print(v[1])
            end for
        else
            converted = []
            for file in globals.db.exploits.get_files
                found = false
                data = libs.decrypt(file.get_content)
                lines = libs.dbParseToLines(data)
                for line in lines
                    v = line.split(":")
                    if v[0] == libname and v[1] == libver then
                        converted.push(line)
                        found = true
                    end if
                end for
                if found then break
            end for

            if doprint then
                for line in converted
                    v = line.split(":")
                    print("  --> " + v[2] + " [" + v[3] + "]")
                end for
            else
                stringify = libs.dbStringifyLines(converted)
                return libs.dbParseExploits(stringify)
            end if
        end if
    end if
    return null
end function

libs["scanLib"] = function(metalib, metax)
    if not metalib then return null
    if not metax then return null

    if globals.db.folder != null and globals.db.hasIndex("exploits") then
        ret = libs.dbQueryExploits(metalib.lib_name, metalib.version)
        if ret != null then return ret
    end if

    ret = {}
    ret.name = metalib.lib_name
    ret.version = metalib.version
    ret.memorys = {}
    memorys = metax.scan(metalib)
    for memory in memorys
        data = metax.scan_address(metalib, memory).split("Unsafe check: ")
        if not data then continue
        ret.memorys[memory] = []
        for line in data
            if line == data[0] then continue
            if line == "" then continue
            value = line[line.indexOf("<b>")+3:line.indexOf("</b>")].replace(char(10), "")
            ret.memorys[memory].push(value)
        end for
    end for

    if globals.db.folder != null and globals.db.hasIndex("exploits") then
        if libs.dbWriteExploits(ret) then
            print("<color=yellow>Library '" + ret.name + "' version " + ret.version + " added.")
        else
            print("<color=orange>Library '" + ret.name + "' version " + ret.version + " already exists.")
        end if
    end if

    return ret
end function

libs["dbStringifyPassword"] = function(result = {})
    if typeof(result) != "map" then return ""
    s = result.pass + ":" + result.hash + ";"
    return s
end function

libs["dbParsePassword"] = function(result = "")
    if typeof(result) != "string" then return null
    if result.indexOf(":") == null then return null

    line = result.split(";")[:-1]
    v = line.split(":")
    ret = {}
    ret["pass"] = v[0]
    ret["hash"] = v[1]
    return ret
end function

libs["dbWritePasswords"] = function(result = "")
    if typeof(result) != "string" then return false

    // Get current file.
    name = "table" + str(globals.db.passwordFilesCount) + ".db"
    file = local.computer.File(globals.db.passwords.path + "/" + name)
    if not file then
        local.computer.touch(globals.db.passwords.path, name)
        file = local.computer.File(globals.db.passwords.path + "/" + name)
        if not file then false
    end if
    
    // Get content and check if in database.
    content = libs.decrypt(file.get_content)
    stringify = libs.dbStringifyPassword({ "pass": result, "hash": md5(result) })
    
    if content.len + stringify.len <= 160000 then
        lines = libs.dbParseToLines(content)
        for line in lines
            v = line.split(":")
            if v[0] == result then
                return false
            end if
        end for

        // Write content to database.
        content = content + stringify
        content = libs.encrypt(content)
        result = file.set_content(content)
        if typeof(result) == "string" then return false
    else
        globals.db.passwordFilesCount = globals.db.passwordFilesCount + 1
        name = "table" + str(globals.db.passwordFilesCount) + ".db"
        file = local.computer.File(globals.db.passwords.path + "/" + name)
        if not file then
            local.computer.touch(globals.db.passwords.path, name)
            file = local.computer.File(globals.db.passwords.path + "/" + name)
            if not file then false
        end if

        // Get content and check if in database.
        content = libs.decrypt(file.get_content)
        stringify = libs.dbStringifyPassword({ "pass": result, "hash": md5(result) })
        
        lines = libs.dbParseToLines(content)
        for line in lines
            v = line.split(":")
            if v[0] == result then
                return false
            end if
        end for

        // Write content to database.
        content = content + stringify
        content = libs.encrypt(content)
        result = file.set_content(content)
        if typeof(result) == "string" then return false
    end if

    return true
end function

libs["dbQueryPasswords"] = function(phash = "")
    if typeof(phash) != "string" then return null

    if phash == "" then
        for file in globals.db.passwords.get_files
            content = libs.decrypt(file.get_content)
            lines = libs.dbParseToLines(content)
            for line in lines
                v = line.split(":")
                print(v[0] + " [" + v[1] + "]")
            end for
        end for
    else
        m = {}
        m["pass"] = ""
        m["hash"] = ""
        for file in globals.db.passwords.get_files
            found = false
            content = libs.decrypt(file.get_content)
            lines = libs.dbParseToLines(content)
            for line in lines
                v = line.split(":")
                if v[1] == phash then
                    m["pass"] = v[0]
                    m["hash"] = v[1]
                    found = true
                    break
                end if
            end for
            if found then break
        end for

        if m.pass != "" and m.hash != "" then
            return m
        end if
    end if
    return null
end function

libs["getPorts"] = function(ip)
    ret = {}
    ret.targetIP = null
    ret.router = null
    ret.ports = null

    targetIP = ip
    if not is_valid_ip(targetIP) then targetIP = nslookup(targetIP)
    if not is_valid_ip(targetIP) then return null

    if is_lan_ip(targetIP) then
        ret.router = get_router
    else
        ret.router = get_router(targetIP)
    end if
    if not ret.router then return null

    if not is_lan_ip(targetIP) then
        ret.ports = ret.router.used_ports
    else
        ret.ports = ret.router.device_ports(targetIP)
    end if
    if typeof(ret.ports) == "string" then return null

    ret.targetIP = targetIP
    return ret
end function

libs["getRandomIP"] = function()
    parts = []
    maxTries = 100
    while maxTries > 0
        parts.push(ceil(rnd * 223))
        parts.push(floor(rnd * 223))
        parts.push(floor(rnd * 223))
        parts.push(floor(rnd * 223))
        ip = parts.join(".")
        if not is_lan_ip(ip) and is_valid_ip(ip) then return ip
        maxTries = maxTries - 1
    end while
    return null
end function

libs["scanPort"] = function(metaxploit, targetIP, targetPort)
    if typeof(metaxploit) != "MetaxploitLib" then return null
    if not is_valid_ip(targetIP) then return null
    if typeof(targetPort) != "number" then return null

    netsession = metaxploit.net_use(targetIP, targetPort)
    if not netsession then
        print(globals.name + ": Cannot get netsession.")
        return null
    end if

    metalib = netsession.dump_lib
    if not metalib then
        print(globals.name + ": Cannot dump lib.")
        return null
    end if

    return libs.scanLib(metalib, metaxploit)
end function

libs["remoteHack"] = function(targetIP, targetPort, injectArg = "")
    if typeof(targetIP) != "string" then return []
    if typeof(targetPort) != "number" then return []
    if typeof(injectArg) != "string" then return []
    if not is_valid_ip(targetIP) then return []

    // Load metaxploit.so into memory.
    metaxploit = include_lib("/lib/metaxploit.so")
    if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/metaxploit.so")
    if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/payload/metaxploit.so")
    if not metaxploit then
        print(globals.name + ": Cannot find metaxploit.so!")
        return []
    end if
    
    netsession = metaxploit.net_use(targetIP, targetPort)
    if not netsession then return []
    metalib = netsession.dump_lib
    if not metalib then return []
    exploits = libs.scanLib(metalib, metaxploit)
    if not exploits then return []

    objects = []
    for exploit in exploits.memorys
        print("<color=#FF0000>" + exploit.key + "</color>")
        for value in exploit.value
            print(char(9) + "<color=#FFFF00>" + value + "</color>")
            object = metalib.overflow(exploit.key, value, injectArg)
            if typeof(object) != "shell" and typeof(object) != "computer" and typeof(object) != "file" then continue
            compinfo = libs.checkIP(object, targetIP, targetPort, get_router)
            if not compinfo then continue
            if objects.indexOf(object) == null then
                objects.push({"object": object, "user": libs.checkUser(object), "addr": exploit.key, "vuln": value, "localip": compinfo.localip, "publicip": compinfo.publicip, "router": compinfo.router })
            end if
        end for
    end for
    
    return objects
end function

libs["localHack"] = function(libName = "", injectArg = "")
    if typeof(libName) != "string" then return []
    if typeof(injectArg) != "string" then return []

    // Load metaxploit.so into memory.
    metaxploit = include_lib("/lib/metaxploit.so")
    if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/metaxploit.so")
    if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/payload/metaxploit.so")
    if not metaxploit then
        print(globals.name + ": Cannot find metaxploit.so!")
        return []
    end if

    metalib = metaxploit.load(libName)
    if not metalib then return []
    exploits = libs.scanLib(metalib, metaxploit)
    if not exploits then return []

    objects = []
    for exploit in exploits.memorys
        print("<color=#FF0000>" + exploit.key + "</color>")
        for value in exploit.value
            print(char(9) + "<color=#FFFF00>" + value + "</color>")
            object = metalib.overflow(exploit.key, value, injectArg)
            if typeof(object) != "shell" and typeof(object) != "computer" and typeof(object) != "file" then continue
            localIP = current.localip
            if typeof(object) == "shell" then localIP = object.host_computer.local_ip
            if typeof(object) == "computer" then localIP = object.local_ip
            if objects.indexOf(object) == null then
                objects.push({"object": object, "user": libs.checkUser(object), "addr": exploit.key, "vuln": value, "localip": localIP, "publicip": current.publicip, "router": current.router })
            end if
        end for
    end for

    return objects
end function

libs["wipeLog"] = function(object)
    if typeof(object) != "shell" and typeof(object) != "computer" and typeof(object) != "file" then return false

    allFiles = libs.findAll(libs.toFile(object))
    if not allFiles then return false
    if allFiles.len == 0 then return false

    files = libs.findAllWithWrite(allFiles)
    if not files then return false
    if files.len == 0 then return false

    file = null
    for f in files
        if f.type == "text" then
            file = f.file
            break
        end if
    end for
    if not file then return false

    result = file.copy("/var", "system.log")
    if typeof(result) == "string" then return false
    file = libs.navTo(object, "/var/system.log")
    if not file then
        print(globals.name + ": <color=orange>Failed to wipe log.</color>")
        return false
    end if
    file.set_content("")
    print(globals.name + ": <color=green>Log cleaned!</color>")
    return true
end function

libs["wipeTool"] = function(object, path = "")
    if typeof(object) != "shell" and typeof(object) != "computer" and typeof(object) != "file" then return false
    if typeof(path) != "string" then return false

    filenames = ["payload", "crypto.so", "metaxploit.so", "ScanLan.exe", program_path.split("/")[-1]]
    for filename in filenames
        fileobj = libs.navTo(object, path + "/" + filename)
        if not fileobj then continue
        result = fileobj.delete
        if result == 0 then
            print(globals.name + ": Could not delete '" + filename + "'.")
        else
            print(globals.name + ": File '" + filename + "' wiped.")
        end if
    end for

    return true
end function

// ------------------ Special Functions ------------------

elevateToRoot = function(dirty, rootHash)
    if typeof(dirty) != "map" then return null
    if typeof(rootHash) != "string" then return null

    // Query database and return if found.
    if globals.db.folder != null and globals.db.hasIndex("passwords") then
        if rootHash != "" then
            m = libs.dbQueryPasswords(rootHash)
            if typeof(m) != "map" then
                // Run decipher on hash.
                print(globals.name + ": <color=yellow>Cracking <b>root</b> hash...</color>")
                password = crypto.decipher(rootHash)
                if not password then
                    print(globals.name + ": <color=red>Cannot decipher password hash.</color>")
                    return null
                end if

                // Write to password database.
                if libs.dbWritePasswords(password) then
                    print(globals.name + ": <color=orange>Password added.</color>")
                    m = {}
                    m["pass"] = password
                    m["hash"] = rootHash
                else
                    print(globals.name + ": <color=white>Password already exists.</color>")
                end if
            else
                print(globals.name + ": <color=yellow>Password found, elevating to root...</color>")
            end if
        else
            print(globals.name + ": <color=yellow>Root hash not found...</color>")
            return null
        end if
    end if

    payload = "if params.len != 1 then exit(""payload: [password]"")" + char(10)
    payload = payload + "shell = get_shell(""root"", params[0])" + char(10)
    payload = payload + "if not shell then exit(""payload: Could not elevate to root."")" + char(10)
    payload = payload + "interface = get_custom_object" + char(10)
    payload = payload + "interface.shell = shell" + char(10)

    // Create payload source and build.
    path = dirty.folder.path
    srcfile = dirty.object.host_computer.File(path + "/a.src")
    if not srcfile then
        dirty.object.host_computer.touch(path, "a.src")
        srcfile = dirty.object.host_computer.File(path + "/a.src")
    end if
    if not srcfile then return false
    srcfile.set_content(payload)
    dirty.object.build(path + "/a.src", path)
    srcfile.delete
    binfile = dirty.object.host_computer.File(path + "/a")
    if not binfile then return false

    // Launch the binary file.
    interface = get_custom_object
    interface.shell = null
    dirty.object.launch(path + "/a", m.pass)
    binfile.delete
    return interface.shell
end function

localElevateFromUser = function(dirty)
    payload = "if params.len != 0 then exit(""payload: No arguments needed."")" + char(10)
    payload = payload + "interface = get_custom_object" + char(10)
    payload = payload + "globals.db = interface.db" + char(10)
    payload = payload + "libs = interface.libs" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "libFolder = get_shell.host_computer.File(""/lib"")" + char(10)
    payload = payload + "if not libFolder then exit(""payload: No lib folder"")" + char(10)
    payload = payload + "libfiles = libFolder.get_files" + char(10)
    payload = payload + "if libfiles.len == 0 then exit(""payload: No lib files"")" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "found = false" + char(10)
    payload = payload + "for libfile in libfiles" + char(10)
    payload = payload + "objs = libs.localHack(libfile.path, """")" + char(10)
    payload = payload + "for obj in objs" + char(10)
    payload = payload + "if obj.user == ""guest"" then continue" + char(10)
    payload = payload + "interface.objects.push(obj)" + char(10)
    payload = payload + "found = true" + char(10)
    payload = payload + "break" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "if found then break" + char(10)
    payload = payload + "end for" + char(10)
    
    // Upload metaxploit.so to remote machine.
    path = dirty.folder.path
    folders = ["/lib", "/bin", "/usr/bin", parent_path(program_path), local.folder.path]
    filenames = ["payload", "metaxploit.so", "crypto.so"]
    for filename in filenames
        for folder in folders
            file = local.object.host_computer.File(folder + "/" + filename)
            if not file then continue
            local.object.scp(file.path, path, dirty.object)
        end for
    end for

    // Create the source file.
    srcfile = dirty.object.host_computer.File(path + "/a.src")
    if not srcfile then
        dirty.object.host_computer.touch(path, "a.src")
        srcfile = dirty.object.host_computer.File(path + "/a.src")
    end if
    if not srcfile then return false
    srcfile.set_content(payload)

    // Build the source file.
    interface = get_custom_object
    interface.db = globals.db
    interface.libs = libs
    interface.objects = []
    dirty.object.build(path + "/a.src", path)
    srcfile.delete
    binfile = dirty.object.host_computer.File(path + "/a")
    if not binfile then return false

    // Launch the binary file.
    dirty.object.launch(path + "/a", "")
    objects = interface.objects
    binfile.delete

    // Cleanup
    libs.wipeTool(dirty.object, path)

    // Loop through objects and check for password.
    if objects.len > 0 then
        rootHash = ""
        for object in objects
            if object.user == "guest" then continue
            print("Public IP: " + object.publicip + char(10) + "Local IP: " + object.localip)
            file = libs.navTo(object.object, "/etc/passwd")
            if not file then continue
            if not file.has_permission("r") then
                print(globals.name + ": Permission denied.")
                continue
            end if
            content = file.get_content
            if content.len < 32 then continue
            rootHash = content[content.indexOf("root:")+5:37]
            break
        end for

        // Elevate to root if root hash found.
        shell = elevateToRoot(dirty, rootHash)
        if shell != null then
            // Cleanup of dirty object.
            libs.wipeLog(shell)
        end if
    end if

    return true
end function

localBounce = function(dirty)
    payload = "if params.len != 0 then exit(""payload: No arguments needed."")" + char(10)
    payload = payload + "interface = get_custom_object" + char(10)
    payload = payload + "globals.db = interface.db" + char(10)
    payload = payload + "libs = interface.libs" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "libFolder = get_shell.host_computer.File(""/lib"")" + char(10)
    payload = payload + "if not libFolder then exit(""payload: No lib folder"")" + char(10)
    payload = payload + "libfiles = libFolder.get_files" + char(10)
    payload = payload + "if libfiles.len == 0 then exit(""payload: No lib files"")" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "found = false" + char(10)
    payload = payload + "for libfile in libfiles" + char(10)
    payload = payload + "objs = libs.localHack(libfile.path, """")" + char(10)
    payload = payload + "for obj in objs" + char(10)
    payload = payload + "if obj.user == ""guest"" then continue" + char(10)
    payload = payload + "interface.objects.push(obj)" + char(10)
    payload = payload + "found = true" + char(10)
    payload = payload + "break" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "if found then break" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "if found then exit(""payload: Got root hash!"")" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "routers = []" + char(10)
    payload = payload + "devices = get_router.devices_lan_ip" + char(10)
    payload = payload + "for lanip in devices" + char(10)
    payload = payload + "if get_router(lanip) != null or get_switch(lanip) != null then" + char(10)
    payload = payload + "if routers.indexOf(lanip) == null then routers = routers + get_router(lanip).devices_lan_ip" + char(10)
    payload = payload + "end if" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "found = false" + char(10)
    payload = payload + "for lanip in routers" + char(10)
    payload = payload + "for libfile in libfiles" + char(10)
    payload = payload + "objs = libs.localHack(libfile.path, lanip)" + char(10)
    payload = payload + "for obj in objs" + char(10)
    payload = payload + "if obj.user == ""guest"" then continue" + char(10)
    payload = payload + "interface.objects.push(obj)" + char(10)
    payload = payload + "found = true" + char(10)
    payload = payload + "break" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "if found then break" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "if found then break" + char(10)
    payload = payload + "end for" + char(10)

    // Upload metaxploit.so to remote machine.
    path = dirty.folder.path
    folders = ["/lib", "/bin", "/usr/bin", parent_path(program_path), local.folder.path]
    filenames = ["payload", "metaxploit.so", "crypto.so"]
    for filename in filenames
        for folder in folders
            file = local.object.host_computer.File(folder + "/" + filename)
            if not file then continue
            local.object.scp(file.path, path, dirty.object)
        end for
    end for

    // Create the source file.
    srcfile = dirty.object.host_computer.File(path + "/a.src")
    if not srcfile then
        dirty.object.host_computer.touch(path, "a.src")
        srcfile = dirty.object.host_computer.File(path + "/a.src")
    end if
    if not srcfile then return false
    srcfile.set_content(payload)

    // Build the source file.
    interface = get_custom_object
    interface.db = globals.db
    interface.libs = libs
    interface.objects = []
    dirty.object.build(path + "/a.src", path)
    srcfile.delete
    binfile = dirty.object.host_computer.File(path + "/a")
    if not binfile then return false

    // Launch the binary file.
    dirty.object.launch(path + "/a", "")
    objects = interface.objects
    binfile.delete

    // Cleanup
    libs.wipeTool(dirty.object, path)

    // Loop through objects and check for password.
    if objects.len > 0 then
        rootHash = ""
        for object in objects
            if object.user == "guest" then continue
            print("Public IP: " + object.publicip + char(10) + "Local IP: " + object.localip)
            file = libs.navTo(object.object, "/etc/passwd")
            if not file then continue
            if not file.has_permission("r") then
                print(globals.name + ": Permission denied.")
                continue
            end if
            content = file.get_content
            if content.len < 32 then continue
            rootHash = content[content.indexOf("root:")+5:37]
            break
        end for

        // Elevate to root if root hash found.
        shell = elevateToRoot(dirty, rootHash)
        if shell != null then
            // Cleanup of dirty object.
            libs.wipeLog(shell)
        end if
    end if

    return true
end function

// ------------------- Shell Commands --------------------

globals.commandsShell = {}

globals.commandsShell["scp"] = { "name": "scp", "desc": "Upload or download from remote system.", "args": "[path | [-d path] | [-u path]]" }
globals.commandsShell["scp"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 and argv.len != 3 then return print(globals.name + ": Does NOT take any arguments.")

    if argv.len == 2 then
        if argv[1].indexOf("/") == 0 then
            result = local.object.scp(argv[1], current.folder.path, current.object)
            if typeof(result) == "string" then return print(globals.name + ": " + result)
        else
            result = local.object.scp(local.folder.path + "/" + argv[1], current.folder.path, current.object)
            if typeof(result) == "string" then return print(globals.name + ": " + result)
        end if
    else
        if argv[1] == "-d" then
            if argv[2].indexOf("/") == 0 then
                result = current.object.scp(argv[2], local.folder.path, local.object)
                if typeof(result) == "string" then return print(globals.name + ": " + result)
            else
                result = current.object.scp(current.folder.path + "/" + argv[2], local.folder.path, local.object)
                if typeof(result) == "string" then return print(globals.name + ": " + result)
            end if
        else if argv[1] == "-u" then
            if argv[2].indexOf("/") == 0 then
                result = local.object.scp(argv[2], current.folder.path, current.object)
                if typeof(result) == "string" then return print(globals.name + ": " + result)
            else
                result = local.object.scp(local.folder.path + "/" + argv[2], current.folder.path, current.object)
                if typeof(result) == "string" then return print(globals.name + ": " + result)
            end if
        end if
    end if
    return true
end function

globals.commandsShell["shell"] = { "name": "shell", "desc": "Execute a shell on remote system.", "args": "" }
globals.commandsShell["shell"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Does NOT take any arguments.")

    if typeof(current.object) == "shell" then
        current.object.start_terminal
        globals.running = false
    else
        print(globals.name + ": You are NOT in a shell.")
    end if
    return true
end function

globals.commandsShell["elevate"] = { "name": "elevate", "desc": "Priviledge elevation using username and password.", "args": "[user] [pass]" }
globals.commandsShell["elevate"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 3 then return print(globals.name + ": Takes two arguments.")

    payload = "if params.len != 2 then exit(""elevate: <user> <pass>"")" + char(10)
    payload = payload + "shell = get_shell(params[0], params[1])" + char(10)
    payload = payload + "if not shell then exit(""elevate: Elevation failed."")" + char(10)
    payload = payload + "interface = get_custom_object" + char(10)
    payload = payload + "interface.shell = shell" + char(10)
    current.object.host_computer.touch(current.folder.path, "a.src")
    srcfile = libs.navTo(current.object, current.folder.path + "/a.src")
    if not srcfile then return print(globals.name + ": Could not create source for elevating.")
    srcfile.set_content(payload)
    current.object.build(current.folder.path + "/a.src", current.folder.path, 0)
    binfile = libs.navTo(current.object, current.folder.path + "/a")
    if not binfile then
        srcfile.delete
        return false
    end if
    interface = get_custom_object
    interface.shell = null
    current.object.launch(current.folder.path + "/a", argv[1] + " " + argv[2])
    if interface.shell != null then
        if globals.objects.indexOf(interface.shell) == null then
            localIP = current.localip
            if typeof(interface.shell) == "shell" then localIP = interface.shell.host_computer.local_ip
            if typeof(interface.shell) == "computer" then localIP = interface.shell.local_ip
            shell = {"object": interface.shell, "user": libs.checkUser(interface.shell), "addr": "", "vuln": "", "localip": localIP, "publicip": current.publicip, "router": current.router }
            current.user = shell.user
            current.object = shell.object
            current.computer = function
                if typeof(shell.object) == "shell" then return shell.object.host_computer
                if typeof(shell.object) == "computer" then return shell.object
                return null
            end function
            current.folder = function
                if shell.user == "root" then
                    return libs.navTo(shell.object, "/root")
                else
                    file = libs.navTo(shell.object, "/home/" + shell.user)
                    if file != null then
                        return libs.navTo(shell.object, file.path)
                    end if
                end if
                return libs.toFile(shell.object)
            end function
            current.router = shell.router
            current.publicip = shell.publicip
            current.localip = shell.localip
            globals.objects.push(shell)
            print("<color=white>If you need this object back.</color>\n<color=white>You can select it with the <b>objects</b> command.</color>")
        end if
    end if
    srcfile.delete
    binfile.delete
    return true
end function

globals.commandsShell["upload"] = { "name": "upload", "desc": "Upload this tool with requirements.", "args": "" }
globals.commandsShell["upload"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Has no arguments.")

    folders = ["/lib", "/bin", "/usr/bin", parent_path(program_path), local.folder.path]
    files = ["payload", "crypto.so", "metaxploit.so", "sh"]
    for file in files
        for folder in folders
            fileobj = libs.navTo(local.object, folder + "/" + file)
            if not fileobj then continue
            result = local.object.scp(fileobj.path, current.folder.path, current.object)
            if typeof(result) == "string" then print(globals.name + ": Could not upload file " + fileobj.name)
            break
        end for
    end for
    interface = get_custom_object
    interface.local = {}
    interface.local.user = local.user
    interface.local.object = local.object
    interface.local.computer = function
        if typeof(interface.local.object) == "shell" then return interface.local.object.host_computer
        if typeof(interface.local.object) == "computer" then return interface.local.object
        return null
    end function
    interface.local.folder = local.folder
    interface.local.router = local.router
    interface.local.publicip = function
        return interface.local.router.public_ip
    end function
    interface.local.localip = local.computer.local_ip
    interface.vfile = vfile
    interface.crypto = crypto
    interface.dirty = dirtyObjects
    result = current.object.launch(current.folder.path + "/sh", "")
    if typeof(result) == "string" then return print(globals.name + ": Could not launch shell.")
    return true
end function

globals.commandsShell["run"] = { "name": "run", "desc": "Run a program on the current system.", "args": "[path/to/binary] [args]" }
globals.commandsShell["run"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 2 then return print(globals.name + ": Takes one or more arguments.")
    result = ""
    cmd = argv[1:2].join("")
    if cmd.indexOf("/") == 0 then
        result = current.object.launch(cmd, argv[2:].join(" "))
    else
        folders = ["/bin", current.folder.path]
        for folder in folders
            computer = current.object.host_computer
            file = computer.File(folder + "/" + cmd)
            if not file then continue
            if not file.has_permission("r") and not file.has_permission("x") then continue
            result = current.object.launch(file.path, argv[2:].join(" "))
            break
        end for
    end if
    if typeof(result) == "string" then return print(globals.name + ": " + result)
    return true
end function

// ----------------- Computer Commands -------------------

globals.commandsComputer = {}

globals.commandsComputer["ps"] = { "name": "ps", "desc": "Display process information.", "args": "" }
globals.commandsComputer["ps"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Takes no arguments.")

    info = "USER PID COMMAND"
    procs = current.computer.show_procs
    for proc in procs.split(char(10))[1:]
        usr = proc.split(" ")[0]
        pid = proc.split(" ")[1]
        cmd = proc.split(" ")[4]
        info = info + char(10) + usr + " " + pid + " " + cmd
    end for
    print(format_columns(info))
    return true
end function

globals.commandsComputer["kill"] = { "name": "kill", "desc": "Kill a running process.", "args": "[pid]" }
globals.commandsComputer["kill"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    pid = argv[1].to_int
    if typeof(pid) != "number" then
        print(globals.name + ": Not a number.")
        return false
    end if
    result = current.computer.close_program(pid)
    if typeof(result) == "string" then
        print(globals.name + ": Cannot close program.")
        return false
    end if
    print(globals.name + ": Program closed.")
    return true
end function

globals.commandsComputer["useradd"] = { "name": "useradd", "desc": "Add a user account to system.", "args": "[user] [pass]" }
globals.commandsComputer["useradd"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 3 then return print(globals.name + ": Takes two arguments.")
    if current.user != "root" then return print(globals.name + ": Must have root access.")

    computer = null
    if typeof(current.object) == "shell" then
        computer = current.object.host_computer
    else if typeof(current.object) == "computer" then
        computer = current.object
    end if
    if not computer then return print(globals.name + ": Not a shell or computer.")
    result = computer.create_user(argv[1], argv[2])
    if typeof(result) == "string" then
        print(globals.name + ": Cannot create user with pass.")
    else
        print(globals.name + ": Created user successfully.")
    end if
    return true
end function

globals.commandsComputer["userdel"] = { "name": "userdel", "desc": "Delete a user account from system.", "args": "[user]" }
globals.commandsComputer["userdel"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")
    if current.user != "root" then return print(globals.name + ": Must have root access.")

    computer = null
    if typeof(current.object) == "shell" then
        computer = current.object.host_computer
    else if typeof(current.object) == "computer" then
        computer = current.object
    end if
    if not computer then return print(globals.name + ": Not a shell or computer.")
    result = computer.delete_user(argv[1], true)
    if typeof(result) == "string" then
        print(globals.name + ": Cannot delete user account.")
    else
        print(globals.name + ": Deleted user successfully.")
    end if
    return true
end function

globals.commandsComputer["chpwd"] = { "name": "chpwd", "desc": "Change a user's password.", "args": "[user] [pass]" }
globals.commandsComputer["chpwd"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 3 then return print(globals.name + ": Takes two arguments.")
    if current.user != "root" then return print(globals.name + ": Must have root access.")

    computer = null
    if typeof(current.object) == "shell" then
        computer = current.object.host_computer
    else if typeof(current.object) == "computer" then
        computer = current.object
    end if
    if not computer then return print(globals.name + ": Not a shell or computer.")
    result = computer.change_password(argv[1], argv[2])
    if result then
        print(globals.name + ": Password not changed.")
        return false
    else
        print(globals.name + ": Password changed.")
    end if
    return true
end function

// ------------------ General Commands -------------------

globals.commands = {}

globals.commands["help"] = { "name": "help", "desc": "Display a list of commands.", "args": "" }
globals.commands["help"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Does NOT take any arguments.")

    info = typeof(current.object) + " commands:" + "\n"
    for command in globals.commands
        info = info + char(9) + command.value.name + " " + command.value.desc + "\n"
    end for

    if typeof(current.object) == "shell" or typeof(current.object) == "computer" then
        for command in globals.commandsComputer
            info = info + char(9) + command.value.name + " " + command.value.desc + "\n"
        end for
        if typeof(current.object) == "shell" then
            for command in globals.commandsShell
                info = info + char(9) + command.value.name + " " + command.value.desc + "\n"
            end for
        end if
    end if

    print(info)
    return true
end function

globals.commands["ls"] = { "name": "ls", "desc": "List the current directory or given directory.", "args": "[(opt) path]" }
globals.commands["ls"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")

    if argv.len == 1 then
        info = "PERM OWNER GROUP NAME"
        folder = current.folder
        if not folder then
            print(globals.name + ": Not found.")
            return false
        end if
        for file in folder.get_folders + folder.get_files
            info = info + char(10) + file.permissions + " " + file.owner + " " + file.group + " " + file.name
        end for
        return print(format_columns(info))
    else if argv.len == 2 then
        info = "PERM OWNER GROUP NAME"
        folder = null
        if argv[1].indexOf("/") == 0 then
            folder = libs.navTo(current.object, argv[1])
        else
            folder = libs.navTo(current.object, current.folder.path + "/" + argv[1])
        end if
        if not folder then
            print(globals.name + ": Not found.")
            return false
        end if
        for file in folder.get_folders + folder.get_files
            info = info + char(10) + file.permissions + " " + file.owner + " " + file.group + " " + file.name
        end for
        print(format_columns(info))
    else
        print(globals.name + ": Invalid number of arguments.")
        return false
    end if
    return true
end function

globals.commands["cd"] = { "name": "cd", "desc": "Change to a different directory.", "args": "[(opt) path]" }
globals.commands["cd"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")

    if argv.len == 1 then
        file = null
        if current.user == "root" then
            file = libs.navTo(current.object, "/root")
        else
            file = libs.navTo(current.object, "/home/" + current.user)
        end if
        if not file then
            print(globals.name + ": Not found.")
            return false
        end if
        current.folder = file
        return print(globals.name + ": Changed directory.")
    else if argv.len == 2 then
        if argv[1] == ".." then
            if current.folder.path != "/" then
                current.folder = current.folder.parent
                print(globals.name + ": Changed directory.")
            else
                print(globals.name + ": Already at root directory.")
            end if
        else
            file = null
            if argv[1].indexOf("/") == 0 then
                file = libs.navTo(current.object, argv[1])
            else
                file = libs.navTo(current.object, current.folder.path + "/" + argv[1])
            end if
            if not file then
                print(globals.name + ": Not found.")
                return false
            end if
            current.folder = file
            print(globals.name + ": Changed directory.")
        end if
    else
        return print(globals.name + ": Invalid number of arguments.")
    end if
    return true
end function

globals.commands["pwd"] = { "name": "pwd", "desc": "Print working directory.", "args": "" }
globals.commands["pwd"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")

    if argv.len == 1 then
        print(current.folder.path)
        return true
    end if
    print(globals.name + ": Invalid number of arguments.")
    return false
end function

globals.commands["rm"] = { "name": "rm", "desc": "Remove the given file or directory.", "args": "[path]" }
globals.commands["rm"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")

    if argv.len == 2 then
        file = null
        if argv[1].indexOf("/") != 0 then
            file = libs.navTo(current.object, current.folder.path + "/" + argv[1])
        else
            file = libs.navTo(current.object, argv[1])
        end if
        if not file then
            print(globals.name + ": Not found.")
            return false
        end if
        if file.is_folder then
            print(globals.name + ": Cannot remove a directory.")
            return false
        end if
        if file.has_permission("w") then
            if file.delete then
                print(globals.name + ": File not deleted!")
                return false
            end if
            print(globals.name + ": File deleted!")
        else
            print(globals.name + ": Permission denied!")
        end if
    else
        print(globals.name + ": Invalid number of arguments.")
    end if
    return true
end function

globals.commands["cat"] = { "name": "cat", "desc": "Print the content of given file.", "args": "[path]" }
globals.commands["cat"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Invalid arguments given.")

    file = null
    if argv[1].indexOf("/") != 0 then
        file = libs.navTo(current.object, current.folder.path + "/" + argv[1])
    else
        file = libs.navTo(current.object, argv[1])
    end if
    if not file then
        print(globals.name + ": Not found.")
        return false
    end if
    if not file.is_folder and file.has_permission("r") then
        print(file.get_content)
    else
        print(globals.name + ": Permission denied!")
    end if
    return true
end function

globals.commands["touch"] = { "name": "touch", "desc": "Create a blank file.", "args": "[path]" }
globals.commands["touch"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    file = null
    if typeof(current.object) == "shell" or typeof(current.object) == "computer" then
        object = current.object
        if typeof(current.object) == "shell" then object = current.object.host_computer
        path = ""
        filename = ""
        if argv[1].indexOf("/") == 0 then
            path = parent_path(argv[1])
            filename = argv[1].split("/")[-1]
        else
            if argv[1].indexOf("/") > 0 then
                path = current.folder.path + "/" + parent_path(argv[1])
                filename = argv[1].split("/")[-1]
            else
                path = current.folder.path
                filename = argv[1]
            end if
        end if
        object.touch(path, filename)
        file = libs.navTo(current.object, path + "/" + filename)
    else
        allFiles = libs.findAll(libs.toFile(current.object))
        if not allFiles then return print(globals.name + ": Not a file object.")
        if allFiles.len == 0 then return print(globals.name + ": No files in root folder.")

        files = libs.findAllWithWrite(allFiles)
        if not files then return print(globals.name + ": Not a list of maps.")
        if files.len == 0 then return print(globals.name + ": Cannot find any files.")

        for f in files
            if f.type == "text" then
                file = f.file
                break
            end if
        end for
        if not file then return print(globals.name + ": File not found.")

        path = ""
        filename = ""
        if argv[1].indexOf("/") == 0 then
            path = parent_path(argv[1])
            filename = argv[1].split("/")[-1]
        else
            if argv[1].indexOf("/") > 0 then
                path = current.folder.path + "/" + parent_path(argv[1])
                filename = argv[1].split("/")[-1]
            else
                path = current.folder.path
                filename = argv[1]
            end if
        end if
        result = file.copy(path, filename)
        file = libs.navTo(current.object, path + "/" + filename)
    end if
    if not file then
        print(globals.name + ": File not created.")
        return false
    end if
    file.set_content("")
    file.set_owner(current.user)
    file.set_group(current.user)
    file.chmod("u+rwx", false)
    file.chmod("g+rwx", false)
    file.chmod("o+rwx", false)
    print(globals.name + ": File was created.")
    return true
end function

globals.commands["mkdir"] = { "name": "mkdir", "desc": "Create an empty directory.", "args": "[path]" }
globals.commands["mkdir"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    file = null
    if typeof(current.object) == "shell" or typeof(current.object) == "computer" then
        object = current.object
        if typeof(current.object) == "shell" then object = current.object.host_computer
        path = ""
        filename = ""
        if argv[1].indexOf("/") == 0 then
            path = parent_path(argv[1])
            filename = argv[1].split("/")[-1]
        else
            if argv[1].indexOf("/") > 0 then
                path = current.folder.path + "/" + parent_path(argv[1])
                filename = argv[1].split("/")[-1]
            else
                path = current.folder.path
                filename = argv[1]
            end if
        end if

        object.create_folder(path, filename)
        file = libs.navTo(current.object, path + "/" + filename)
        if not file then
            print(globals.name + ": Directory not created.")
            return false
        end if
    else
        allFiles = libs.findAll(libs.toFile(current.object))
        if not allFiles then return print(globals.name + ": Not a file object.")
        if allFiles.len == 0 then return print(globals.name + ": No files in root folder.")

        files = libs.findAllWithWrite(allFiles)
        if not files then return print(globals.name + ": Not a list of maps.")
        if files.len == 0 then return print(globals.name + ": Cannot find any files.")

        file = null
        for f in files
            if f.type == "folder" then
                file = f.file
                break
            end if
        end for
        if not file then return print(globals.name + ": File not found.")

        path = ""
        filename = ""
        if argv[1].indexOf("/") == 0 then
            path = parent_path(argv[1])
            filename = argv[1].split("/")[-1]
        else
            if argv[1].indexOf("/") > 0 then
                path = current.folder.path + "/" + parent_path(argv[1])
                filename = argv[1].split("/")[-1]
            else
                path = current.folder.path
                filename = argv[1]
            end if
        end if
        file.copy(path, filename)
        file = libs.navTo(current.object, path + "/" + filename)
        if not file then
            print(globals.name + ": Directory not created.")
            return false
        end if

        files = file.get_folders + file.get_files
        while files.len > 0
            f = files.pull
            f.delete
        end while
    end if
    file.set_owner(current.user)
    file.set_group(current.user)
    file.chmod("u+rwx", true)
    file.chmod("g+rwx", true)
    file.chmod("o+rwx", true)
    print(globals.name + ": Directory was created.")
    return true
end function

globals.commands["rmdir"] = { "name": "rmdir", "desc": "Remove a directory.", "args": "[path]" }
globals.commands["rmdir"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    file = null
    if argv[1].indexOf("/") == 0 then
        file = libs.navTo(current.object, argv[1])
    else
        file = libs.navTo(current.object, current.folder.path + "/" + argv[1])
    end if
    if not file then return print(globals.name + ": Directory not found.")
    if not file.is_folder then return print(globals.name + ": Not a directory.")
    if not file.has_permission("w") then return print(globals.name + ": Permission denied.")
    if file.delete then
        print(globals.name + ": Cannot delete directory.")
        return false
    end if
    print(globals.name + ": Directory deleted.")
    return true
end function

globals.commands["chmod"] = { "name": "chmod", "desc": "Change a file's permissions.", "args": "[(opt) -R] [ugo-/+rwx] [path]" }
globals.commands["chmod"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 3 and argv.len != 4 then return print(globals.name + ": Takes two or three arguments.")

    file = null
    if argv[-1].indexOf("/") == 0 then
        file = libs.navTo(current.object, argv[-1])
    else
        file = libs.navTo(current.object, current.folder.path + "/" + argv[-1])
    end if
    if not file then
        print(globals.name + ": File or directory not found.")
        return false
    end if
    result = null
    if argv[1] == "-R" then
        result = file.chmod(argv[-2], true)
    else
        result = file.chmod(argv[-2], false)
    end if
    if result then
        print(globals.name + ": Failed to set permission.")
        return false
    end if
    print(globals.name + ": Permissions set.")
    return true
end function

globals.commands["chown"] = { "name": "chown", "desc": "Change a file's owner and group.", "args": "[(opt) -R] [user:group] [path]" }
globals.commands["chown"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 3 and argv.len != 4 then return print(globals.name + ": Takes two or three arguments.")

    file = null
    if argv[-1].indexOf("/") == 0 then
        file = libs.navTo(current.object, argv[-1])
    else
        file = libs.navTo(current.object, current.folder.path + "/" + argv[-1])
    end if
    if not file then
        print(globals.name + ": File or directory not found.")
        return false
    end if
    owner = null
    group = null
    if argv[-2].indexOf(":") > 0 then
        owner = argv[-2].split(":")[0]
        group = argv[-2].split(":")[1]
    end if
    if typeof(owner) != "string" or typeof(group) != "string" then
        print(globals.name + ": Cannot get owner and group, improper formatting.")
        return false
    end if
    if argv[1] == "-R" then
        if file.set_owner(owner, true) == 0 then
            print(globals.name + ": Failed to set owner.")
            return false
        else
            print(globals.name + ": Owner set.")
        end if
        if file.set_group(group, true) == 0 then
            print(globals.name + ": Failed to set owner.")
            return false
        else
            print(globals.name + ": Group set.")
        end if
    else
        if file.set_owner(owner, false) == 0 then
            print(globals.name + ": Failed to set owner.")
            return false
        else
            print(globals.name + ": Owner set.")
        end if
        if file.set_group(group, false) == 0 then
            print(globals.name + ": Failed to set owner.")
            return false
        else
            print(globals.name + ": Group set.")
        end if
    end if
    return true
end function

globals.commands["ssh"] = { "name": "ssh", "desc": "Connect to remote shell.", "args": "[user@pass] [ip] [(opt) port]" }
globals.commands["ssh"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 3 or argv.len > 4 then return print(globals.name + ": Takes three arguments one is optional.")

    creds = argv[1].split("@")
    user = creds[0]
    pass = creds[1]

    targetIP = argv[2]
    if not is_valid_ip(targetIP) then targetIP = nslookup(targetIP)
    if not is_valid_ip(targetIP) then
        print(globals.name + ": Unknown network address.")
        return false
    end if

    targetPort = 22
    if argv.len > 3 then targetPort = argv[3].to_int
    if typeof(targetPort) != "number" then
        print(globals.name + ": Target port has to be a number.")
        return false
    end if
    if targetPort <= 0 or targetPort > 65535 then
        print(globals.name + ": Target port out of range.")
        return false
    end if

    object = get_shell.connect_service(targetIP, targetPort, user, pass, "ssh")
    if typeof(object) != "shell" then
        print(globals.name + ": Cannot connect to ssh service.")
        return false
    end if

    globals.objects.push({"object": object, "user": libs.checkUser(object), "addr": "ssh", "vuln": "ssh", "localip": object.host_computer.local_ip, "publicip": object.host_computer.public_ip, "router": get_router(object.host_computer.public_ip) })
    print("<color=white>Please use <b>objects</b> command to use this object.</color>")
    return true
end function

globals.commands["ftp"] = { "name": "ftp", "desc": "Connect to remote ftp shell.", "args": "[user@pass] [ip] [(opt) port]" }
globals.commands["ftp"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 3 or argv.len > 4 then return print(globals.name + ": Takes three arguments one is optional.")

    creds = argv[1].split("@")
    user = creds[0]
    pass = creds[1]

    targetIP = argv[2]
    if not is_valid_ip(targetIP) then targetIP = nslookup(targetIP)
    if not is_valid_ip(targetIP) then
        print(globals.name + ": Unknown network address.")
        return false
    end if

    targetPort = 22
    if argv.len > 3 then targetPort = argv[3].to_int
    if typeof(targetPort) != "number" then
        print(globals.name + ": Target port has to be a number.")
        return false
    end if
    if targetPort <= 0 or targetPort > 65535 then
        print(globals.name + ": Target port out of range.")
        return false
    end if

    object = get_shell.connect_service(targetIP, targetPort, user, pass, "ftp")
    if typeof(object) != "shell" then
        print(globals.name + ": Cannot connect to ftp service.")
        return false
    end if

    print("<color=white>Starting ftp shell...</color>")
    object.start_terminal
    return true
end function

globals.commands["link"] = { "name": "link", "desc": "Display IP information.", "args": "" }
globals.commands["link"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Takes no arguments.")

    if current.computer != null and not current.computer.is_network_active then
        print(globals.name + ": No network connection.")
        return false
    end if

    print("ESSID: " + current.router.essid_name)
    print("BSSID: " + current.router.bssid_name)
    print("Public IP: " + current.publicip)
    print("Local IP: " + current.localip)
    if current.computer != null then
        print("Gateway: " + current.computer.network_gateway)
    else
        print("Gateway: 0.0.0.0")
    end if
    return true
end function

globals.commands["scan"] = { "name": "scan", "desc": "Port scanner and database writer.", "args": "[IP] [(opt) Port]" }
globals.commands["scan"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 2 or argv.len > 3 then return print(globals.name + ": Invalid arguments given.")

    if argv.len == 2 then
        ret = libs.getPorts(argv[1])
        if not ret then return print(globals.name + ": Network address not found.")
        if ret.ports.len == 0 then return print(globals.name + ": Scan finished. No ports found.")

        info = "PORT STATE SERVICE VERSION LAN"
        for port in ret.ports
            servinfo = ret.router.port_info(port)
            status = "open"

            if not is_lan_ip(ret.targetIP) and port.is_closed then
                status = "closed"
            end if
            info = info + char(10) + port.port_number + " " + status + " " + servinfo + " " + port.get_lan_ip
        end for
        print(format_columns(info))
    else if argv.len == 3 then
        // Load metaxploit.so into memory.
        metaxploit = include_lib("/lib/metaxploit.so")
        if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/metaxploit.so")
        if not metaxploit then exit(globals.name + ": Cannot find metaxploit.so!")

        if argv[2] == "all" then
            if globals.db.folder == null or globals.hasIndex("exploits") then return print(globals.name + ": Not connected to database.")
            ret = libs.getPorts(argv[1])
            if not ret then return print(globals.name + ": Network address not found.")
            if ret.ports.len == 0 then return print(globals.name + ": Scan finished. No ports found.")

            libs.scanPort(metaxploit, ret.targetIP, 0)
            for port in ret.ports
                if not is_lan_ip(ret.targetIP) and port.is_closed then
                    continue
                end if

                libs.scanPort(metaxploit, ret.targetIP, port.port_number)
            end for
        else
            targetPort = argv[2].to_int
            if typeof(targetPort) == "number" then
                if globals.db.folder == null or globals.hasIndex("exploits") then return print(globals.name + ": Not connected to database.")
                targetIP = argv[1]
                if not is_valid_ip(targetIP) then targetIP = nslookup(targetIP)
                if not is_valid_ip(targetIP) then
                    print(globals.name + ": Target IP not found.")
                    return false
                end if

                libs.scanPort(metaxploit, targetIP, targetPort)
            else
                print(globals.name + ": Port given was not a number.")
                return false
            end if
        end if
    else
        print(globals.name + ": Invalid arguments given.")
    end if
    return true
end function

globals.commands["oclear"] = { "name": "oclear", "desc": "Clear all objects.", "args": "" }
globals.commands["oclear"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Takes no arguments.")

    globals.objects = []
    print(globals.name + ": Objects cleared.")
    return true
end function

globals.commands["rshell"] = { "name": "rshell", "desc": "Get rshell objects or start rshell on remote machine.", "args": "[(opt) [ip] [port]]" }
globals.commands["rshell"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 and argv.len != 3 then return print(globals.name + ": Takes two optional arguments.")

    // Load metaxploit.so into memory.
    metaxploit = include_lib("/lib/metaxploit.so")
    if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/metaxploit.so")
    if not metaxploit then exit(globals.name + ": Cannot find metaxploit.so!")
    
    if argv.len == 1 then
        if (current.publicip != local.publicip and current.localip != local.localip) then
            print(globals.name + ": <color=red>Backdoor server only available on local object.</color>")
            return false
        end if

        globals.objects = []
        rshells = metaxploit.rshell_server
        if typeof(rshells) == "string" then
            print(globals.name + ": <color=red>rshelld service not running.</color>")
            return false
        end if

        for object in rshells
            if not globals.objects.hasIndex(object) then
                globals.objects.push({"object": object, "user": libs.checkUser(object), "addr": "rshell", "vuln": "rshell", "localip": object.host_computer.local_ip, "publicip": object.host_computer.public_ip, "router": get_router(object.host_computer.public_ip) })
            end if
        end for

        if rshells.len == 0 then
            print(globals.name + ": No rshell objects found.")
            return false
        else
            print(globals.name + ": Please use objects command.")
        end if
    else
        if current.publicip == local.publicip and current.localip == local.localip then
            print(globals.name + ": <color=red>Backdoor only available on remote machine.</color>")
            return false
        end if

        targetIP = argv[1]
        if not is_valid_ip(targetIP) then targetIP = nslookup(argv[1])
        if not is_valid_ip(targetIP) then
            print(globals.name + ": Invalid domain name or IP.")
            return false
        end if

        targetPort = argv[2].to_int
        if typeof(targetPort) != "number" then
            print(globals.name + ": Needs to be a number.")
            return false
        end if
        if targetPort < 0 or targetPort > 65535 then
            print(globals.name + ": Port given out of range.")
            return false
        end if

        object = metaxploit.rshell_client(targetIP, targetPort, "rsh")
        if typeof(object) == "string" or not object then
            print(globals.name + ": Cannot create a backdoor.")
            return false
        end if

        print(globals.name + ": Please use rshell without arguments for objects.\n" + globals.name + ": Created a backdoor.")
    end if
    return true
end function

globals.commands["rhack"] = { "name": "rhack", "desc": "Remote machine exploitation.", "args": "[IP] [Port] [(opt) injectArg]" }
globals.commands["rhack"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 3 or argv.len > 4 then return print(globals.name + ": Invalid arguments given.")

    targetIP = argv[1]
    if not is_valid_ip(targetIP) then targetIP = nslookup(targetIP)
    if not is_valid_ip(targetIP) then
        print(globals.name + ": Target IP not valid.")
        return false
    end if

    injectArg = ""
    if argv.len > 3 then injectArg = argv[3]

    targetPort = argv[2].to_int
    if typeof(targetPort) != "number" then
        print(globals.name + ": Target Port is not a number.")
        return false
    end if
    if targetPort < 0 or targetPort > 65535 then
        print(globals.name + ": Target port is out of range.")
        return false
    end if

    objects = libs.remoteHack(targetIP, targetPort, injectArg)
    if objects.len == 0 then
        print(globals.name + ": No exploits found.")
        return false
    end if

    if objects.len > 0 then
        for object in objects
            dirty = {}
            dirty.user = object.user
            dirty.object = object.object
            dirty.computer = object.object
            if not dirty.computer and typeof(object.object) == "shell" then dirty.computer = object.object.host_computer
            if not dirty.computer and typeof(object.object) == "file" then dirty.computer = null
            dirty.folder = libs.navTo(object.object, "/home/" + object.user)
            if dirty.user == "root" then dirty.folder = libs.navTo(object.object, "/root")
            if not dirty.folder then dirty.folder = libs.navTo(object.object, "/")
            dirty.router = object.router
            dirty.publicip = object.publicip
            dirty.localip = object.localip
            if dirtyObjects.indexOf(dirty) == null then
                dirtyObjects.push(dirty)
            end if
            if globals.objects.indexOf(dirty) == null then
                globals.objects.push(dirty)
            end if
        end for
        print("<color=white>Please use <b>objects</b> command to switch to remote machine.</color>")
    end if
    return true
end function

globals.commands["lhack"] = { "name": "lhack", "desc": "Local machine exploitation.", "args": "[path/to/lib] [(opt) injectArg]" }
globals.commands["lhack"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 2 or argv.len > 3 then return print(globals.name + ": Invalid arguments given.")

    injectArg = ""
    if argv.len > 2 then injectArg = argv[2]

    objects = libs.localHack(argv[1], injectArg)
    if objects.len == 0 then
        print(globals.name + ": No exploits found.")
        return false
    end if

    if objects.len > 0 then
        for object in objects
            dirty = {}
            dirty.user = object.user
            dirty.object = object.object
            dirty.computer = object.object
            if not dirty.computer and typeof(object.object) == "shell" then dirty.computer = object.object.host_computer
            if not dirty.computer and typeof(object.object) == "file" then dirty.computer = null
            dirty.folder = libs.navTo(object.object, "/home/" + object.user)
            if dirty.user == "root" then dirty.folder = libs.navTo(object.object, "/root")
            if not dirty.folder then dirty.folder = libs.navTo(object.object, "/")
            dirty.router = object.router
            dirty.publicip = object.publicip
            dirty.localip = object.localip
            if dirtyObjects.indexOf(dirty) == null then
                dirtyObjects.push(dirty)
            end if
            if globals.objects.indexOf(dirty) == null then
                globals.objects.push(dirty)
            end if
        end for
        print("<color=white>Please use <b>objects</b> command to switch to remote machine.</color>")
    end if
    return true
end function

globals.commands["wipe"] = { "name": "wipe", "desc": "Clean the system of my shell.", "args": "" }
globals.commands["wipe"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")

    answer = ""
    while answer != "y" and answer != "Y" and answer != "n" and answer != "N"
        answer = user_input("Do you wish to wipe (Y/N)? ", 0, 0)
        answer = answer.trim
    end while
    if answer == "n" or answer == "N" then return print(globals.name + ": Not wiping.")
    libs.wipeTool(current.object, current.folder.path)
    return libs.wipeLog(current.object)
end function

globals.commands["clear"] = { "name": "clear", "desc": "Clear the terminal screen.", "args": "" }
globals.commands["clear"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")
    return clear_screen
end function

globals.commands["local"] = { "name": "local", "desc": "Switch back to local machine.", "args": "" }
globals.commands["local"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")
    if current.publicip == local.publicip and current.localip == local.localip then
        return print(globals.name + ": <color=yellow>Already on <b>local</b> machine.</color>")
    end if
    current.user = local.user
    current.object = local.object
    current.computer = local.computer
    current.folder = local.folder
    current.router = local.router
    current.publicip = local.computer.public_ip
    current.localip = local.computer.local_ip
    return true
end function

globals.commands["remote"] = { "name": "remote", "desc": "Switch back to remote machine.", "args": "" }
globals.commands["remote"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")
    if remote.publicip == local.publicip and remote.localip == local.localip then
        return print(globals.name + ": <color=orange>Not connected to a <b>remote</b> machine.</color>")
    end if
    if current.publicip == remote.publicip and current.localip == remote.localip then
        return print(globals.name + ": <color=yellow>Already on <b>remote</b> machine.</color>")
    end if
    current.user = remote.user
    current.object = remote.object
    current.computer = remote.computer
    current.folder = remote.folder
    current.router = remote.router
    current.publicip = remote.computer.public_ip
    current.localip = remote.computer.local_ip
    return true
end function

globals.commands["dirty"] = { "name": "dirty", "desc": "List all dirty objects.", "args": "" }
globals.commands["dirty"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")
    if dirtyObjects.len == 0 then return print(globals.name + ": No dirty objects found.")
    i = 0
    info = "ID TYPE ACCESS PUBLIC LOCAL"
    for dirty in dirtyObjects
        info = info + char(10) + str(i) + " " + typeof(dirty.object) + " " + dirty.user + " " + dirty.publicip + " " + dirty.localip
        i = i + 1
    end for
    print(format_columns(info))
    return true
end function

globals.commands["scrub"] = { "name": "scrub", "desc": "Clean up all dirty objects.", "args": "" }
globals.commands["scrub"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")
    if dirtyObjects.len == 0 then return print(globals.name + ": No dirty objects found.")
    print(globals.name + ": <color=white>Scrubbing dirty ojects...</color>")
    while dirtyObjects.len > 0
        dirty = dirtyObjects.pull
        if typeof(dirty.object) == "shell" then
            print(globals.name + ": <color=yellow>Scrubbing dirty shell objects...</color>")
            if dirty.user == "guest" then
                if dirty.router.public_ip == dirty.publicip and dirty.router.local_ip == dirty.localip then
                    // Is a router.
                    if localBounce(dirty) then
                        index = dirtyObjects.indexOf(dirty)
                        if index != null then
                            dirtyObjects.remove(index)
                        end if
                    end if
                else
                    if localElevateFromUser(dirty) then
                        index = dirtyObjects.indexOf(dirty)
                        if index != null then
                            dirtyObjects.remove(index)
                        end if
                    end if
                end if
            else if dirty.user == "root" then
                libs.wipeTool(dirty.object, dirty.folder.path)
                if libs.wipeLog(dirty.object) then
                    index = dirtyObjects.indexOf(dirty)
                    if index != null then
                        dirtyObjects.remove(index)
                    end if
                end if
            else
                // Wipe tool off computer.
                libs.wipeTool(dirty.object, dirty.folder.path)

                // Elevate from user to root.
                file = libs.navTo(dirty.object, "/etc/passwd")
                if not file then return false
                if not file.has_permission("r") then return false
                content = file.get_content
                if content.len < 32 then return false
                rootHash = content[content.indexOf("root:")+5:37]
                shell = elevateToRoot(dirty, rootHash)
                if shell != null then
                    libs.wipeLog(shell)
                    index = dirtyObjects.indexOf(dirty)
                    if index != null then
                        dirtyObjects.remove(index)
                    end if
                end if
            end if
        else
            if dirty.user == "root" then
                print(globals.name + ": <color=yellow>Scrubbing dirty object...</color>")
                // Clean log file.
                if libs.wipeLog(dirty.object) then
                    index = dirtyObjects.indexOf(dirty)
                    if index != null then
                        dirtyObjects.remove(index)
                    end if
                end if
            else
                print(globals.name + ": <color=orange>Removing dirty object, that cannot be scrubbed...</color>")
                index = dirtyObjects.indexOf(dirty)
                if index != null then
                    dirtyObjects.remove(index)
                end if
            end if
        end if
    end while
    return true
end function

globals.commands["objects"] = { "name": "objects", "desc": "Display all objects or select an object.", "args": "[(opt) ID]" }
globals.commands["objects"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 2 then return print(globals.name + ": Takes one optional argument.")

    if argv.len == 1 then
        if globals.objects.len == 0 then return print(globals.name + ": No objects found!")
        i = 0
        info = "ID TYPE ACCESS PUBLIC LAN"
        for object in globals.objects
            info = info + char(10) + str(i) + " " + typeof(object.object) + " " + object.user + " " + object.publicip + " " + object.localip
            i = i + 1
        end for
        print(format_columns(info))
    else
        objectid = argv[1].to_int
        if typeof(objectid) == "string" then return print(globals.name + ": Has to be a number.")
        if (objectid < 0 or objectid > (globals.objects.len - 1)) then
            return print(globals.name + ": Object ID out of range.")
        end if
        current.user = globals.objects[objectid].user
        current.object = globals.objects[objectid].object
        current.computer = globals.objects[objectid].object
        if typeof(globals.objects[objectid].object) == "shell" then current.computer = globals.objects[objectid].object.host_computer
        if typeof(globals.objects[objectid].object) == "file" then current.computer = null
        globals.objects[objectid].folder = libs.navTo(globals.objects[objectid].object, "/home/" + globals.objects[objectid].user)
        if globals.objects[objectid].user == "root" then globals.objects[objectid].folder = libs.navTo(globals.objects[objectid].object, "/root")
        if not globals.objects[objectid].folder then globals.objects[objectid].folder = libs.navTo(globals.objects[objectid].object, "/")
        current.folder = globals.objects[objectid].folder
        current.router = globals.objects[objectid].router
        current.publicip = globals.objects[objectid].publicip
        current.localip = globals.objects[objectid].localip
        if dirtyObjects.indexOf(globals.objects[objectid]) == null then
            dirtyObjects.push(globals.objects[objectid])
        end if
    end if
    return true
end function

globals.commands["decrypt"] = { "name": "decrypt", "desc": "Decrypt a password hash.", "args": "[hash]" }
globals.commands["decrypt"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    // Query database and return if found.
    if globals.db.folder != null and globals.db.hasIndex("passwords") then
        m = libs.dbQueryPasswords(argv[1])
        if typeof(m) == "map" then
            print("<color=white>Password: " + m.pass + "</color>")
            return true
        end if
    end if

    // Run decipher on hash.
    password = crypto.decipher(argv[1])
    if not password then
        print(globals.name + ": <color=red>Cannot decipher password hash.</color>")
        return false
    end if

    // Write to database.
    if globals.db.folder != null and globals.db.hasIndex("passwords") then
        if libs.dbWritePasswords(password) then
            print(globals.name + ": <color=orange>Password added.</color>")
            print(globals.name + ": <color=white>Password: " + password + "</color>")
            return true
        else
            print(globals.name + ": <color=white>Password already exists.</color>")
        end if
    end if

    return false
end function

globals.commands["random"] = { "name": "random", "desc": "Get a random IP to hack.", "args": "" }
globals.commands["random"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Takes NO arguments.")

    randomIP = libs.getRandomIP
    if not randomIP then
        print("Cannot get random IP.")
        return false
    end if
    print("Random global IP: " + randomIP)
    return true
end function

globals.commands["dbscan"] = { "name": "dbscan", "desc": "Scan systems to write to database.", "args": "[amount]" }
globals.commands["dbscan"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")
    if not globals.db.hasIndex("exploits") or (globals.db.hasIndex("exploits") and globals.db.exploits == null) then return print(globals.name + ": Not connected to database.")

    // Load metaxploit.so into memory.
    metaxploit = include_lib("/lib/metaxploit.so")
    if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/metaxploit.so")
    if not metaxploit then return print(globals.name + ": Cannot find metaxploit.so!")

    amount = argv[1].to_int
    if typeof(amount) != "number" then
        print(globals.name + ": Not given a number.")
        return false
    end if

    if amount <= 0 or amount > 25 then
        print(globals.name + ": Out of range; only 1 to 25.")
        return false
    end if

    while amount > 0
        ip = libs.getRandomIP
        if not ip then
            print(globals.name + ": Cannot get random IP.")
            return false
        end if
        ret = libs.getPorts(ip)
        if not ret then
            print(globals.name + ": Failed to get ports.")
            continue
        end if

        if ret.ports.len == 0 then
            print(globals.name + ": Scan finished. No ports found.")
            continue
        end if

        libs.scanPort(metaxploit, ret.targetIP, 0)
        for port in ret.ports
            if not is_lan_ip(ret.targetIP) and port.is_closed then
                continue
            end if

            libs.scanPort(metaxploit, ret.targetIP, port.port_number)
        end for
        amount = amount - 1
    end while

    return true
end function

globals.commands["dbquery"] = { "name": "dbquery", "desc": "Query the database.", "args": "[dbname] [(opt) [libname] or [hash]] [(opt) libver]" }
globals.commands["dbquery"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 4 then return print(globals.name + ": Takes two arguments one is optional.")
    if not globals.db.hasIndex("exploits") or (globals.db.hasIndex("exploits") and globals.db.exploits == null) then return print(globals.name + ": Not connected to database.")

    if argv.len == 4 then
        if argv[1] == "exploits" then
            libs.dbQueryExploits(argv[2], argv[3], true)
        else
            print(globals.name + ": <color=orange>Database entry does NOT exist.</color>")
        end if
    else if argv.len == 3 then
        if argv[1] == "passwords" then
            m = libs.dbQueryPasswords(argv[2])
            if typeof(m) == "map" then
                print("<color=white>Password: " + m.pass + "</color>")
            else
                print(globals.name + ": <color=orange>Cannot lookup hash maybe improperly formatted.</color>")
            end if
        else if argv[1] == "exploits" then
            libs.dbQueryExploits(argv[2], "")
        else
            print(globals.name + ": <color=orange>Database entry does NOT exist.</color>")
        end if
    else if argv.len == 2 then
        if argv[1] == "passwords" then
            libs.dbQueryPasswords("")
        else if argv[1] == "exploits" then
            libs.dbQueryExploits("", "")
        else
            print(globals.name + ": <color=orange>Database entry does NOT exist.</color>")
        end if
    else
        print("Databases Available:")
        for dbname in globals.db.names
            print("  " + dbname)
        end for
        print(globals.name + ": <color=white>You must atleast specify a database name.</color>")
    end if
    return true
end function

globals.commands["dbcreate"] = { "name": "dbcreate", "desc": "Create a database.", "args": "" }
globals.commands["dbcreate"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Takes no arguments.")
    if libs.dbCheck then
        print("<color=red>Database already exists.")
        return true
    end if
    return libs.dbCreate
end function

globals.commands["dbdelete"] = { "name": "dbdelete", "desc": "Delete an entry from the database.", "args": "[(opt) dbname]" }
globals.commands["dbdelete"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 2 then return print(globals.name + ": Takes one optional argument.")
    if not globals.db.hasIndex("exploits") or (globals.db.hasIndex("exploits") and globals.db.exploits == null) then return print(globals.name + ": Not connected to database.")

    if argv.len == 2 then
        if libs.dbDelete(argv[1]) then
            print("<color=yellow>Database deleted.</color>")
        else
            print("<color=orange>Database failed to delete.</color>")
        end if
    else
        if libs.dbDelete then
            print("<color=yellow>Database deleted.</color>")
        else
            print("<color=orange>Database failed to delete.</color>")
        end if
    end if
    return true
end function

globals.commands["clean"] = { "name": "clean", "desc": "Clear the log file.", "args": "" }
globals.commands["clean"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Does NOT take any arguments.")
    if current.user != "root" then print(globals.name + ": <color=orange>You must have <b>root</b> access.</color>")

    return libs.wipeLog(current.object)
end function

globals.commands["secure"] = { "name": "secure", "desc": "Secure your local machine or a remote server.", "args": "[type]" }
globals.commands["secure"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")
    if current.user != "root" then return print(globals.name + ": This command requires root priviledges.")

    if argv[1] == "local" then
        rootFolder = libs.navTo(local.object, "/")
        if not rootFolder then
            print(globals.name + ": Root directory not found.")
            return false
        end if
        result1 = rootFolder.set_owner("root", true)
        result2 = rootFolder.set_group("root", true)
        if result1 or result2 then
            print(globals.name + ": Root directory owner and/or group NOT set.")
            return false
        end if
        print(globals.name + ": Root directory owner and/or group set.")
        rootFolder.chmod("o-rwx", true)
        rootFolder.chmod("g-rwx", true)
        rootFolder.chmod("u+rwx", true)
        print(globals.name + ": Permissions set on root directory recursively.")

        filenames = ["Terminal.exe", "AdminMonitor.exe", "ScanLan.exe", "sudo", "payload", "metaxploit.so", "crypto.so", program_path.split("/")[-1]]
        folders = ["/lib", "/bin", "/usr/bin", parent_path(program_path), local.folder.path]
        for filename in filenames
            for folder in folders
                file = libs.navTo(local.object, folder + "/" + filename)
                if not file then continue
                file.set_owner("root", false)
                file.set_group("root", false)
                print(globals.name + ": File owner and/or group set on '" + file.name + "'.")
                if file.name == "sudo" then
                    file.chmod("o-rx", false)
                    file.chmod("g+rx", false)
                    file.chmod("u+rwx", false)
                else
                    file.chmod("o+rx", false)
                    file.chmod("g+rx", false)
                    file.chmod("u+rwx", false)
                end if
                print(globals.name + ": Permissions set on '" + file.name + "'.")
                break
            end for
        end for
        print(globals.name + ": Secured local machine.")
    else if argv[1] == "remote" then
        rootFolder = libs.navTo(current.object, "/")
        if not rootFolder then
            print(globals.name + ": Root directory not found.")
            return false
        end if
        result1 = rootFolder.set_owner("root", true)
        result2 = rootFolder.set_group("root", true)
        if result1 or result2 then
            print(globals.name + ": Root directory owner and/or group NOT set.")
            return false
        end if
        print(globals.name + ": Root directory owner and/or group set.")
        rootFolder.chmod("o-rwx", true)
        rootFolder.chmod("g-rwx", true)
        rootFolder.chmod("u+rwx", true)
        print(globals.name + ": Permissions set on root directory recursively.")

        answer = ""
        while answer != "y" and answer != "Y" and answer != "n" and answer != "N"
            answer = user_input("Do you wish to secure a router (Y/N)? ")
        end while

        filenames = ["Terminal.exe", "AdminMonitor.exe", "ScanLan.exe", "payload", "metaxploit.so", "crypto.so", program_path.split("/")[-1]]
        if answer == "y" or answer == "Y" then
            filenames = ["Terminal.exe", "AdminMonitor.exe", "ScanLan.exe", "sudo", "metaxploit.so", "crypto.so", program_path.split("/")[-1]]
            print(globals.name + ": Securing router...")
        else
            print(globals.name + ": Securing server...")
        end if

        folders = ["/lib", "/bin", "/usr/bin", parent_path(program_path), current.folder.path]
        for filename in filenames
            for folder in folders
                file = libs.navTo(current.object, folder + "/" + filename)
                if not file then continue
                file.set_owner("root", false)
                file.set_group("root", false)
                print(globals.name + ": File owner and/or group set on '" + file.name + "'.")
                if file.name == "sudo" then
                    file.chmod("o-rx", false)
                    file.chmod("g+rx", false)
                    file.chmod("u+rwx", false)
                else
                    file.chmod("o+rx", false)
                    file.chmod("g+rx", false)
                    file.chmod("u+rwx", false)
                end if
                print(globals.name + ": Permissions set on '" + file.name + "'.")
            end for
        end for
        print(globals.name + ": Secured remote machine.")
    else
        print(globals.name + ": Valid types are 'local' or 'remote'.")
        return false
    end if
    return true
end function

globals.commands["vfile"] = { "name": "vfile", "desc": "Add or clear files to/from virtual file array.", "args": "[(opt) [path]]" }
globals.commands["vfile"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 2 then return print(globals.name + ": Takes two arguments and they are optional arguments.")

    if argv.len == 2 then
        file = null
        if argv[1].indexOf("/") == 0 then
            file = libs.navTo(globals.current.object, argv[1])
        else
            file = libs.navTo(globals.current.object, globals.current.folder.path + "/" + argv[1])
        end if
        if not file then
            print(globals.name + ": File not found.")
            return false
        end if
        if not file.has_permission("r") then
            print(globals.name + ": Permission denied.")
            return false
        end if
        globals.vfile.push(file)
        print("<color=yellow>File added.</color>")
    else
        if typeof(current.object) == "shell" then
            if vfile.len > 0 then
                option = -1
                while option < 0 or option > vfile.len
                    i = 1
                    info = "ID PATH FILE" + char(10) + "0" + " " + "All"
                    for file in vfile
                        info = info + char(10) + str(i) + " " + parent_path(file.path) + " " + file.name
                        i = i + 1
                    end for
                    print(format_columns(info))

                    option = user_input("Enter ID (Blank to quit): ").to_int
                    if typeof(option) != "number" then break
                end while

                if typeof(option) != "number" then
                    print(globals.name + ": <color=white>You chose to quit.</color>")
                else
                    if option != 0 then
                        result = current.object.scp(vfile[option-1].path, local.folder.path, local.object)
                        if typeof(result) == "string" then
                            print(globals.name + ": <color=yellow>Virtual file failed to download.</color>")
                        else
                            print(globals.name + ": <color=yellow>Virtual file downloaded.</color>")
                        end if
                    else
                        print(globals.name + ": <color=yellow>Downloading all virtual files...")
                        for file in vfile
                            result = current.object.scp(file.path, local.folder.path, local.object)
                            if typeof(result) == "string" then
                                print(globals.name + ": <color=yellow>Virtual file failed to download.</color>")
                            else
                                print(globals.name + ": <color=yellow>Virtual file downloaded.</color>")
                            end if
                        end for
                    end if
                end if
            else
                print(globals.name + ": <color=yellow>There are no files in virtual file storage.</color>")
            end if
        else
            print("<color=yellow>Get a <b>shell</b> for transfer.</color>")
        end if

        answer = ""
        while answer != "y" and answer != "Y" and answer != "n" and answer != "N"
            answer = user_input("Do you want to clear virtual file objects (Y/N)? ")
        end while
        if answer == "n" or answer == "N" then return false
        globals.vfile = []
        print("<color=white>Virtual files cleared.</color>")
    end if
    return true
end function

globals.commands["find"] = { "name": "find", "desc": "Find all files or all readable, writeable or executable.", "args": "[(opt) -rwx]" }
globals.commands["find"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 2 then return print(globals.name + ": Takes one optional argument.")

    allFiles = libs.findAll(libs.toFile(current.object))
    if not allFiles then return print(globals.name + ": Not a file object.")
    if allFiles.len == 0 then return print(globals.name + ": No files in root folder.")
    
    if argv.len == 2 then
        if argv[1] == "-r" then
            files = libs.findAllWithRead(allFiles)
            if not files then return print(globals.name + ": Not a list.")
            if files.len == 0 then return print(globals.name + ": Cannot find any files.")

            for file in files
                print(file.file.path)
            end for
        else if argv[1] == "-w" then
            files = libs.findAllWithWrite(allFiles)
            if not files then return print(globals.name + ": Not a list.")
            if files.len == 0 then return print(globals.name + ": Cannot find any files.")

            for file in files
                print(file.file.path)
            end for
        else if argv[1] == "-x" then
            files = libs.findAllWithExec(allFiles)
            if not files then return print(globals.name + ": Not a list.")
            if files.len == 0 then return print(globals.name + ": Cannot find any files.")

            for file in files
                print(file.file.path)
            end for
        else
            print(globals.name + ": Unknown option '" + argv[1] + "'.")
        end if
    else
        for file in allFiles
            print(file.path)
        end for
    end if
    return true
end function

globals.commands["whois"] = { "name": "whois", "desc": "Lookup information about an internet address.", "args": "[ip]" }
globals.commands["whois"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    isDomain = false
    targetIP = argv[1]
    if not is_valid_ip(targetIP) then
        targetIP = nslookup(targetIP)
        if not is_valid_ip(targetIP) then
            print(globals.name + ": Invalid IP or domain name.")
            return false
        end if
        isDomain = true
    end if
    if isDomain then
        print("Domain IP: " + targetIP)
    end if
    print(whois(targetIP))
    return true
end function

globals.commands["nslookup"] = { "name": "nslookup", "desc": "Lookup information about a domain.", "args": "[www.domain.com]" }
globals.commands["nslookup"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    result = nslookup(argv[1])
    if not is_valid_ip(result) then
        print(globals.name + ": Invalid domain name.")
        return false
    end if
    print("Domain Name: " + argv[1] + "\nDomain IP: " + result)
    return true
end function

globals.commands["version"] = { "name": "version", "desc": "Version number of this shell.", "args": "" }
globals.commands["version"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes NO arguments.")
    print("Shell version: " + str(globals.version))
    print("Creation Date: " + globals.date)
    print("Developer: " + globals.coder)
    return true
end function

globals.commands["exit"] = { "name": "exit", "desc": "Exit this shell.", "args": "" }
globals.commands["exit"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes NO arguments.")
    globals.running = false
    return true
end function

// ----------------- Main Program --------------------

if params.len != 0 then exit("Usage: " + program_path.split("/")[-1])

// Execute given command with arguments.
CommandExecute = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid type, needs to be of type 'string'.")
    //if argv.len > 1 and argv[1] == "" then return print(globals.name + ": No arguments given when expected.")

    commands = globals.commands
    if typeof(current.object) == "shell" or typeof(current.object) == "computer" then
        commands = commands + globals.commandsComputer
        if typeof(current.object) == "shell" then
            commands = commands + globals.commandsShell
        end if
    end if

    if not commands.hasIndex(argv[0].lower.trim) then return print(globals.name + ": Command not found!")
    command = commands[argv[0].lower.trim]
    if argv.len > 1 then
        if argv[1] == "-h" or argv[1] == "--help" then
            return print("Usage: " + command.name + " " + command.args)
        end if
    end if

    return command.run(argv)
end function

// Splash screen for my shell.
splash = "=============================" + char(10)
splash = splash + "=   ////////    //      //  =" + char(10)
splash = splash + "=  //      //   //      //  =" + char(10)
splash = splash + "=  //           //      //  =" + char(10)
splash = splash + "=   ////////    //////////  =" + char(10)
splash = splash + "=          //   //      //  =" + char(10)
splash = splash + "=  //      //   //      //  =" + char(10)
splash = splash + "=   ////////    //      //  =" + char(10)
splash = splash + "=============================" + char(10)
splash = splash + "       Version " + globals.version + char(10)
splash = splash + "      Coded by " + globals.coder + char(10)
print(splash)

// Connect to the database server if there is one available.
if libs.dbCheck then
    print("<color=yellow>Database Status:</color> <color=green>Available</color>")
else
    print("<color=yellow>Database Status:</color> <color=red>Not Available</color>")
end if

// Main Loop for a shell.
while globals.running
    input = user_input("<color=#33AA88>" + current.user + "@" + current.publicip + " [" + typeof(current.object) + "] # ", 0, 0)
    if input == "" then continue
    CommandExecute(input.trim.split(" "))
end while
